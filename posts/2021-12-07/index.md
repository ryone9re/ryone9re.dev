---
title: 'Rustプログラミング言語学習記 Part1 (#1 事始め､ #3 一般的なプログラミングの概念)'
date: '2021-12-07'
tags: ['Rust', '入門']
---

Rust に入門することにしました｡

Rust 学習中につまずいたりなるほどと思ったポイントをアウトプットがてら書き連ねていこうと思います｡

手始めに公式のチュートリアルから読むことにしました｡

[The Rust Programming Language 日本語](https://doc.rust-jp.rs/book-ja/)

この記事は､上記の｢[#1 事始め](https://doc.rust-jp.rs/book-ja/ch01-00-getting-started.html)｣｢[#3 一般的なプログラミングの概念](https://doc.rust-jp.rs/book-ja/ch03-00-common-programming-concepts.html)｣についてのアウトプットです｡

インプットとアウトプットを同時に行っているので､更新遅いです｡

※は僕のコメントです｡

<br>

## #1

### **rustup**

rustup は Rust ツールチェインのインストーラー､バージョンマネージャー｡

### **rustc**

Rust のコンパイラ｡

### **cargo**

Rust のビルドシステム､パッケージマネージャ｡

<br>

新規バイナリプロジェクトを作成する際には以下のコマンドを入力する｡

```Rust
cargo new project_name --bin
```

上記コマンドを入力すると､バイナリの実行ファイルが生成される｡

<br>

### **Cargo.toml**

`[package]`セクションは Cargo がプログラムをコンパイルする際の基本情報である｡

- 必要な情報は環境から自動で取得されるが､修正することもできる｡

`[dependencies]`セクションは､プログラムが依存するクレートを列挙される｡

<br>

### **Cargo でビルド**

cargo build を実行すると､`target/debug/{project_name}`へ実行バイナリがビルドされる｡

- `--release`オプションをつけることで､リリース版のビルドを行える｡

`cargo run`を実行することで､ビルドから実行までを 1 コマンドで行える｡

- cargo はプロジェクトの変更を検知するので､変更がない場合はビルドを行わない｡

`cargo check`はプログラムがコンパイル可能か確認する｡

<br>

### **Rust プログラム**

Rust では`src/main.rs`がプロジェクトルートとなる｡

- ファイル名に複数の単語がある場合はアンダースコアを使用し単語間を区切る｡

**main function** がプログラムのエントリポイントとなる｡

```Rust
fn main() {
//この中にプログラムを記述する
}
```

Rust では文末に`;`を入力し､式では入力しない｡

<br>

## #3.1 変数と可変性

変数宣言は`let`で行う｡

Rust ではスネークケースを使用するのが一般的である｡

```Rust
let x = 5;
```

その際､変数はイミュータブルである｡

また､`mut`をつけることでミュータブルな変数を宣言できる｡

```Rust
let mut x = 5;
```

イミュータブルな変数に再代入しようとすると､コンパイラがエラーを吐いてくれる｡

故に値が不変であることをコンパイラが保証してくれる｡

変数は､スコープが外れる / 所有権を失う(#4) とそれ以後使用できない｡

<br>

### **シャドーイング**

イミュータブルな変数は覆い隠すことができる｡

つまり､以下のように一度宣言したイミュータブルな変数と同名の別の値を宣言することができる｡

```Rust
let x = 5;
let x = x + 1;
let x = x * 2;
```

このとき､x は 12 である｡

この x(12)は最初に宣言した x(5)とは同名だが別の変数になる｡

`mut`との違いとして､`mut`は変数の示す物の値を変えるのに対し､**シャドーイング**では全く別の変数を宣言していることになるので､メモリ上のアドレスも変わる｡

_※シャドーイングができるのは所有権システムのおかげ?_

シャドーイングを用いるメリットとして､同じ内容を表すものに同じ名前を与えることができるので､名前を考える手間が省けることがあげられる｡

```Rust
let num_char = "NumberOfCharactersIs22";
let num_char = num_char.len();
// num_char = 22
```

<br>

定数は`const`で宣言できる｡

```Rust
const MY_HEIGHT: u32 = 185;
```

定数を宣言する際は**必ず**型を注釈しなければいけない｡

定数はアッパースネークケースで宣言する｡

<br>

## #3.2 データ型

Rust は強い静的型付け言語であり､コンパイル時にすべての値の型が判明している必要がある｡

複数な型が選択できるデータの場合､型注釈をつける必要がある｡(数値型等)

データ型には主に 2 種類ある｡

<br>

### **スカラー型**

スカラー型は実値を持つ単独の値である｡

Rust では主に**整数型**､**浮動小数点型**､**論理値型**､**文字型**の 4 つが使用される｡

<br>

#### **数値型**

符号付きと符号なしが選べる｡

| 大きさ | 符号付き | 符号なし |
| :----- | :------- | :------- |
| 8-bit  | `i8`     | `u8`     |
| 16-bit | `i16`    | `u16`    |
| 32-bit | `i32`    | `u32`    |
| 64-bit | `i64`    | `u64`    |
| arch   | `isize`  | `usize`  |

`isize`と`usize`は実行するコンピュータのアーキテクチャに依存する｡

基準型は`i32`であり､基本的にはどのアーキテクチャでも最速である｡

`isize`と`usize`を使用する主な状況は､何らかのコレクションにアクセスする際である｡

<br>

整数リテラルは以下の形式で記述できる｡

| 数値リテラル      | 例            |
| :---------------- | :------------ |
| 10 進数           | `98_222`      |
| 16 進数           | `0xff`        |
| 8 進数            | `0o77`        |
| 2 進数            | `0b1111_0000` |
| バイト (`u8`だけ) | `b'A'`        |

<br>

#### **浮動小数点型**

浮動小数点型には 2 種類の基本型があり､`f32`と`f64`がある｡

基準値は`f64`であり､現代のコンピュータでは`f32`とほぼ同速で精度がより高い｡

<br>

#### **論理値型**

論理値型は`bool`で表され､取りうる値は`true`と`false`のみである｡

主に制御フローで使用される｡

<br>

#### **文字型**

文字型は`char`で表される｡

Unicode のスカラー値であり､`U+0000`から`U+D7FF`と`U+E000`から`U+10FFFF`までが利用できる｡

ただし､｢文字｣は Unicode の概念ではないので､人間の直観とはそぐわない可能性がある｡

<br>

### **複合型**

#### **タプル**

タプルは複数の型の集合体である｡

丸括弧にカンマ区切りの値をリストとして書くことで生成できる｡

```Rust
let tup: (i32, f64, u8) = (500, 6.4, 1);
```

上記変数`tup`はタプル全体に束縛されている｡

タプルはパターンマッチングを利用して値を個別に取り出すことができ､アンダースコアで捨てることができる｡

タプルから取り出す際は､要素をすべて取り出すようにしなければならない｡

```Rust
let (x, y, _) = tup;
// x = 500, y = 6.4
let (x, y) = tup;
// error[E0308]: mismatched types
// expected a tuple with 3 elements, found one with 2 elements
```

また､アクセスしたい値の番号をピリオドに続いて書くことで､タプルの要素にアクセスすることができる｡

要素の添字は 0 より始まる｡

```Rust
println!("{}", tup.0);
// 500
```

<br>

#### **配列型**

タプルと異なり､配列の要素はすべて同じ型である必要がある｡

Rust の配列は固定長である｡

配列を宣言するには角括弧にカンマ区切りの値をリストで記述する｡

`[配列の型; 配列の長さ]`

```Rust
let arr: [i32; 3] = [5, 10, 33];
```

配列はスタックとしてメモリに格納される｡

配列の要素にアクセスするには角括弧の中に要素の添字を入力することでアクセスできる｡

```Rust
println!("{}", arr[0]);
// 5
```

配列の要素数を超えてアクセスしようとすると､コンパイルは正常に終了するが**実行時エラー**となり､パニックで終了する｡

```Rust
println!("{}", arr[10]);
// error: this operation will panic at runtime
// index out of bounds: the length is 3 but the index is 10
```

Rust では無効なメモリにアクセスする際､アクセスは許可するものの即座に終了することで保護している｡

<br>

## #3.3 関数

関数は`fn`によって宣言できる｡

`main function`はプログラムのエントリポイントとなる｡

Rust ではスネークケースで宣言することが一般的である｡

```Rust
fn main() {
    println!("Hello, world!");
    another_function();
}

fn another_function() {
    println!("Another function."); // 別の関数
}
```

<br>

### **関数の引数**

関数は引数を取ることができる｡

関数宣言の際､関数名の後ろの丸括弧に仮引数として記述することで､関数内で使用できる｡

```Rust
fn bmi_printer(height: f32, weight: f32) {
    println!("{}", weight / (height * height));
}
```

仮引数の型は必ず宣言する必要がある｡

複数の仮引数をもたせる場合は､カンマのあとに続けて記述できる｡

<br>

### **関数の戻り値**

関数は値を返すことができ､矢印`->`のあとに型を書いて宣言できる｡

```Rust
fn bmi_calculator(height: f32, weight: f32) -> f32 {
    weight / (height * height)
}
```

Rust では最後に評価された式の値が返される｡

また､`return`を記述することで早期リターンを行うことができる｡

最後に文(`;`で終わる物)を返そうとするとエラーが発生するが､その際戻り値は`()`､つまり空のタプルとして表現される｡

```Rust
fn bmi_calculator(height: f32, weight: f32) -> f32 {
    weight / (height * height);
}
// error[E0308]: mismatched types
// implicitly returns`()`as its body has no tail or`return`expression
```

<br>

## #3.4 コメント

スラッシュを 2 つ続けて記述することで､コメントを書くことができる｡

コメントは文末まで適応される｡

複数行にまたがる場合､各行の先頭に 2 連スラッシュを入力する｡

```Rust
// This is a comment.
// This is a comment too.
```

<br>

## #3.4 フロー制御

### **if 式**

条件によって枝分かれさせることができる｡

`else`は､条件が偽のときに実行される｡

`else if`を使用することで､複数の条件式でフロー制御ができる｡

```Rust
let x = 5;
if x < 10 { // <-条件式
    println!("x is under 10!");
} else if x > 3 { // <-条件式
    println!("x is under 10 but over 3");
} else {
    println!("x is under 3");
}
// x is under 10 but over 3
```

条件式は`bool`型でなければならない｡

`bool`型でなければエラーが発生する｡

Rust では､論理値以外の型が暗黙的に論理値に変換されることは**ない**｡

明示的にし､条件式として必ず論理値を与える必要がある｡

```Rust
let number = 100;
if number {
    println!("number is there");
}
// error[E0308]: mismatched types
// expected`bool`, found integer
```

<br>

`if`は式なので､評価値を代入することができます｡

_※let 句は文なので`;`忘れに注意_

```Rust
let number = if true {
    5
} else {
    100
};
// number = 5
```

このとき､最後に評価される値(戻り値)は同じ型でないとエラーが発生する｡

```Rust
let number = if true {
    5
} else {
    "hundred"
};
// error[E0308]:`if`and`else`have incompatible types
```

<br>

**note:**

タプルを最後に評価した場合､パターンマッチング表記で受けることができる｡

```Rust
let (num1, num2) = if true {
    (5, 10)
} else {
    (100, 300)
};
println!("{} and {}", num1, num2);
```

<br>

### **ループ**

`loop`を使用することで､無限ループできる｡

```Rust
loop {
    println!("again");
}
// again
// again
...
```

プロセスを強制終了することで停止できる｡

<br>

### **条件付きループ**

`while`を使用することで､条件を指定してループできる｡

条件が真でなくなったとき､`break`を呼ぶことで､ループを抜ける｡

```Rust
let mut x = 1;
while x < 4 {
    println!("{}", x);
    x = x + 1;
}
println!("Dah!");
// 1
// 2
// 3
// Dah!
```

<br>

### **コレクションを取り出す**

`for`ループを使用することで､イテレータのそれぞれの要素に対して処理することができる｡

_※イテレータについては後の記事で詳しくまとめます｡_

```Rust
let user = ["太郎", "次郎", "三郎"];
for s in user.iter() {
    println!("Hello {}", s);
}
// Hello 太郎
// Hello 次郎
// Hello 三郎
```

次回は [#4 所有権](https://ryone9re.link/2021-12-12)になります｡
