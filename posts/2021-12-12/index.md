---
title: 'Rustプログラミング言語学習記 Part2 (#4 所有権)'
date: '2021-12-12'
tags: ['Rust', '入門']
---

Rust に入門することにしました｡

Rust 学習中につまずいたりなるほどと思ったポイントをアウトプットがてら書き連ねていこうと思います｡

手始めに公式のチュートリアルから読むことにしました｡

[The Rust Programming Language 日本語](https://doc.rust-jp.rs/book-ja/)

この記事は､上記の｢[#4 所有権](https://doc.rust-jp.rs/book-ja/ch04-00-understanding-ownership.html)｣についてのアウトプットです｡

インプットとアウトプットを同時に行っているので､更新遅いです｡

※は僕のコメントです｡

<br>

## #4.1 所有権とは

所有権を理解するにあたって重要なのは､変数の値が**スタック**に保管されるのか､**ヒープ**に保管されるのかである｡

リテラルな値はサイズがコンパイル時にサイズが分かるため､全てスタックに保管され､スコープを抜けるとスタックから取り除かれる｡

また値は最終的にバイナリファイルに直接ハードコードされる｡

- ハードコードとは､バイナリファイルに直接記述されていることである｡

コンパイル時にサイズがわからないものは､ヒープに保管される｡

<br>

### **String 型**

String 型はコンパイル時にサイズが不明なテキストを保持することができる｡

そのため､ヒープにメモリを確保する｡

String 型は`from`関数を使用して､文字列リテラルより生成できる｡

```Rust
let s = String::from("hello");
```

(上記`::`は String 型直下の`from`関数を特定する働きを持つ｡ 詳しくは[#5.3 メソッド記法](https://doc.rust-jp.rs/book-ja/ch05-03-method-syntax.html)､[#7 モジュール定義](https://doc.rust-jp.rs/book-ja/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html)を参照)

このような文字列は可変化することができる｡

```Rust
let mut s = String::from("hello");
s.push_str(", world!");
println!("{}", s);
// Hello, world!
```

なぜ､String 型は可変化できて､リテラルができないか､違いはこの 2 つの型のメモリを扱う方法の違いにある｡

<br>

### **メモリと確保**

コンパイル時にサイズが不明であったり､サイズが可変なものはコンパイル時にメモリ量を確保することは不可能である｡

そのため､コンパイル時には不明な量のメモリをヒープに確保し内容を保持する｡

なので

1. メモリは､実行時に OS に要求される
1. `String`型を使用し終わったら､OS にメモリを返還する

この 2 つを行う必要がある｡

1 は`String::from`関数を呼ぶ際に､その実装が必要なメモリを要求するため､すでに実行されている｡

よって必要な動作は 2 のみである｡

一般的なプログラミング言語ではガベージコレクタで不要なメモリを検知し掃除する､もしくはプログラマが明示的にメモリを返還する､このどちらかになるが､Rust では**所有権システム**により､メモリを管理している｡

<br>

### **所有権規則**

所有権のルールは主に以下の 3 つである｡

- Rust の各値は､所有者と呼ばれる変数と対応している｡

- いかなる時も所有者は一つである｡

- 所有者がスコープを外れると､その値は破棄される｡

```Rust
{ // ① ここでは変数sは有効ではない
    let s = String::from("Hello"); // ② sはここから有効になる
    priontln!("{}", s);
} // ④ ここで変数sはスコープを抜ける
// 変数sはここでは有効ではない
```

上記例では､`"Hello"`の所有者は変数`s`であり､スコープを抜ける ④ のタイミングで破棄される｡

変数がスコープを抜ける時､Rust は特別な関数を呼び出す｡

この関数は`drop`と呼ばれ､プログラマはメモリを返還するコードを記述することができる｡

Rust では閉じ波括弧で自動的に`drop`関数を呼び出す｡

(このパターンは､Rust コードの書かれ方に甚大な影響をもたらす｡ヒープ上に確保されたデータを複数の変数に使用させるようなもっと複雑な場面では､コードの振る舞いは､予期しないものになる可能性もある｡)

<br>

### **変数とデータの相互作用法: ムーブ**

Rust では､複数の変数が同じデータに対して異なる手段で相互作用することができる｡

#### **スカラー型の場合**

```Rust
let x = 5;
let y = x;
// x == 5
// y == 5
```

固定長な値であるスカラー型の場合､値はコピーされる｡

なぜなら､既知の固定サイズの単純な値で､これらの値はスタックに積まれるからである｡

<br>

#### **ベクタ型の場合**

```Rust
let s1 = String::from("hello");
let s2 = s1;
```

可変長な値であるベクタ型の場合､スタックに存在するデータはコピーされるが､参照しているヒープ上にあるデータはコピーされず､そのポインタを保持している｡

**note:**

- ポインタ

  - オブジェクトのインスタンスのメモリ上のアドレス

  - つまり､値が保存されているメモリ上の場所を数字で表したもの

(もし､ヒープデータもコピーされていた場合､`s1 = s2`という処理の実行時性能がとても悪くなる可能性がある)

上述のコードで､s1 と s2 は同時にスコープを抜けるが､この時二重解放エラーが起こることはない｡

Rust では確保されたメモリをコピーする代わりに､コンパイラが`s1`が有効ではないと考え､`s1`がスコープを抜けたときに何も開放しない｡

よって､メモリ上のデータ表現は以下の様になる｡

![s1 のポインタ､長さ､許容量のコピーを保持する変数 s2 のメモリ上での表現](https://cloud.r3utools.com/s/gep5mLDNKT357T3/preview 's1のポインタ､長さ､許容量のコピーを保持する変数s2のメモリ上での表現')

> Image from [図 4-2: s1 のポインタ、長さ、許容量のコピーを保持する変数 s2 のメモリ上での表現](https://doc.rust-jp.rs/book-ja/img/trpl04-06.svg '図 4-2: s1 のポインタ、長さ、許容量のコピーを保持する変数 s2 のメモリ上での表現')

```Rust
let s1 = String::from("hello");
let s2 = s1;

println!("{}, world!", s1);
// error[E0382]: use of moved value: `s1`
// note: move occurs because `s1` has type `std::string::String`, which does not implement the `Copy` trait
```

コンパイラは無効化された参照を使用できないようにするので､上記のようなエラーが発生する｡

このようにデータのコピーなしにポインタと長さ､許容量をコピーし､最初の変数を無効化することを**ムーブ**と呼ぶ｡

このような挙動を**ムーブセマンティクス**という｡

この例では､`s1`は`s2`にムーブされたと表現できる｡

よって､スコープを抜ける際､`s2`のみを解放し､正常に終了する｡

**note:**

つまり､Rust では自動的に deep copy が行われることがない｡それ故に､あらゆる自動コピーは実行時性能の観点でいうと悪くないと考えて良い｡

<br>

### **変数とデータの相互作用: クローン**

ヒープデータの`deep copy`が必要な場合､`clone`メソッドを実行できる｡

```Rust
let s1 = String::from("Hello");
let s2 = s1.clone();
println!("s1={}, s2={}", s1, s2);
// s1=Hello, s2=Hello
```

このメソッドでは以下の状態を明示的に生み出せる｡

![Rustがヒープデータもコピーしていた場合にs2 = s1という処理が行なった可能性のあること](https://cloud.r3utools.com/s/tt3jayinSgM3dke/preview 'Rustがヒープデータもコピーしていた場合にs2 = s1という処理が行なった可能性のあること')

> Image from [図 4-3: Rust がヒープデータもコピーしていた場合に s2 = s1 という処理が行なった可能性のあること](https://doc.rust-jp.rs/book-ja/img/trpl04-03.svg '図4-3: Rustがヒープデータもコピーしていた場合にs2 = s1という処理が行なった可能性のあること')

<br>

### **スカラー値のコピー**

スカラー型のデータはスタック上に値が保持されるので､コピーが高速である｡

なので､変数`x`を変数`y`にムーブしたとしても､変数`x`を無効化する理由がないことになり､コピーされることになる｡

このような挙動を**コピーセマンティクス**という｡

つまり､スカラー値には shallow copy と deep copy の違いがない(参照する必要がない)ことになり`clone`メソッドを実行する必要もない｡

よってそのまま放置できる｡

Rust には`copy`**トレイト**があり､これを実装している､若しくは注釈を添えている時にコピーセマンティクスになる｡

**note:**

Rust における**トレイト**とは実装を持つインターフェースのようなものであり､一般的なプログラミング言語におけるトレイトとは**別物**｡

一般規則として､スタックに確保されるスカラー値の集合は全てコピーセマンティクスである｡

| コピーセマンティクスな値の一覧                               |
| ------------------------------------------------------------ |
| 整数型`u32`等                                                |
| 浮動小数点型`f64`等                                          |
| 論理値型`bool`                                               |
| 文字型`char`                                                 |
| コピーセマンティクスな値のみで構成されるタプル`(i32, i32)`等 |

メモリ確保が必要であったり､なんらかの形態のリソースであるものはコピーセマンティクス**ではない**｡

<br>

### **所有権と関数**

関数に値を渡すと､代入と同じくムーブやコピーされる｡

```Rust
fn main() {
    let s = String::from("hello");  // sがスコープに入る

    takes_ownership(s);             // sの値が関数にムーブされるので､
                                    // <-ここではもう有効ではない

    let x = 5;                      // xがスコープに入る

    makes_copy(x);                  // xも関数にムーブされるが､i32はCopyなので、この後にxを使っても問題ない

} // ここでxがスコープを抜け､sもスコープを抜ける｡ただし､sの値はムーブされているので､何も特別なことは起こらない｡xは破棄される｡

fn takes_ownership(some_string: String) { // some_stringがスコープに入る(今回の例では渡されたs)

    println!("{}", some_string);

} // ここでsome_stringがスコープを抜け､dropが呼ばれる｡後ろ盾してたメモリが解放される｡

fn makes_copy(some_integer: i32) { // some_integerがスコープに入る(今回の例では渡されたx)

    println!("{}", some_integer);

} // ここでsome_integerがスコープを抜ける｡コピーセマンティクスなので何も特別なことはない｡
```

<br>

### **戻り値とスコープ**

値を返すことでも所有権は移動する｡

```Rust
fn main() {
    let s1 = gives_ownership();         // gives_ownershipによって作られた戻り値の所有権はs1にムーブする

    let s2 = String::from("hello");     // s2がスコープに入る

    let s3 = takes_and_gives_back(s2);  // s2と所有権はtakes_and_gives_backにムーブされ戻り値と所有権もs3にムーブされる

} // ここで､s1とs3はスコープを抜け､ドロップされる｡s2もスコープを抜けるが､ムーブされているので､何も起きない

fn gives_ownership() -> String {             // gives_ownershipは､戻り値を呼び出した関数にムーブする

    let some_string = String::from("hello"); // some_stringがスコープに入る

    some_string                              // some_stringが返され､呼び出し元関数にムーブされる
}

// takes_and_gives_backは､Stringを一つ受け取り､返す｡
fn takes_and_gives_back(a_string: String) -> String { // a_stringがスコープに入る

    a_string  // a_stringが返され､呼び出し元関数にムーブされる

}
```

<br>
<br>

## #4.2 参照と借用

Rust の関数は引数にオブジェクトの**参照**を取ることができる｡

関数の引数に参照を取ることを**借用**と呼ぶ｡

参照とは､ポインタをもとに､値を確認することである｡

**参照の規則**

- 任意のタイミングで､1 つの可変参照か複数の不変な参照どちらかを行える｡

- 参照は常に有効でなければならない｡

```Rust
fn main() {
    let s1 = String::from("Space");
    let len = calculate_length(&s1);

    println!("{}", s1);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

オブジェクトの参照を渡す際､参照演算子`&`をつけることで値を参照することができる｡ -> 値を参照するポインタを渡している

また､関数側では引数の型に`&`をつけることによって､参照を受け取ることができる｡ -> 値を参照するポインタを受け取っている

これらによって､以下のように所有権を移動することなく､関数内で値を参照することができる｡

![`String s1`を指す`&String s`の図表](https://cloud.r3utools.com/s/eAByq7oKjBjZyGy/preview '`String s1`を指す`&String s`の図表')

> Image from [図 4-5: `String s1`を指す`&String s`の図表](https://doc.rust-jp.rs/book-ja/img/trpl04-05.svg '図4-5: `String s1`を指す`&String s`の図表')

```Rust
fn calculate_length(s: &String) -> usize { // sはStringへの参照
    s.len()
} // ここで､sはスコープを外れるが､持っているのは渡されたStringの参照のため､所有権を持っておらず､何も起こらない
```

上記コードでは引数として受け取るものはオブジェクトの参照であるが､所有権を渡されているわけではないので､スコープを外れた際､渡されたオブジェクトの所有権は破棄されず､何も起こらない｡

借用は標準で不変であるため､参照しているなにかを変更することはできない｡

<br>

### **可変な参照**

借用に 1 手間加えるだけで､可変な参照を受けることができる｡

```Rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s); // 変更点①
}

fn change(some_string: &mut String) { // 変更点②
    some_string.push_str(", world");
}
```

参照を渡す･受け取る際に､`mut` (`&mut`)を付け加えることで､可変な参照を扱うことができる｡

ただし､**可変な参照はスコープ内で 1 つしか持てない**｡

この制約がある利点は、コンパイラがコンパイル時にデータ競合を防ぐことができる点である｡

データ競合とは、競合条件と類似していて、これら 3 つの振る舞いが起きる時に発生する:

- 2 つ以上のポインタが同じデータに同時にアクセスする
- 少なくとも一つのポインタがデータに書き込みを行っている
- データへのアクセスを同期する機構が使用されていない

Rust は、データ競合が起こるコードをコンパイルすらしないため､これらの問題が発生しない｡

波括弧を使用し新しいスコープを生成することで､**同時並行ではない**､複数の可変な参照を作成できる｡

```Rust
let mut s = String::from("Hello");
{
    let r1 = &mut s;
} // r1はここでスコープを抜けるため､以降では新たな可変な参照を作ることができる

let r2 = &mut s;
```

また､不変な参照を行っている間は､可変な参照を行うことができない｡

なぜなら､不変な参照を行っているものは､その値が変わることを予期していないからである｡

```Rust
let mut s = String::from("Hello");

let r1 = &s; // OK
let r2 = &s; // OK
let r3 = &mut s; // ERROR!!

// error[E0502]: cannot borrow `s` as mutable because it is also borrowed as immutable
```

<br>

### **宙に浮いた参照**

Rust では､ポインタがダングリングポインタでないことを､コンパイラが保証してくれる｡

- ダングリングポインタとは､他人に渡されてしまった可能性のあるメモリを指すポインタのことであり､その箇所へのポインタを保持している間に､メモリを解放してしまうことで発生する｡

そのため､以下のようにダングリングポインタを作成しようとすると､コンパイルエラーが発生する｡

```Rust
fn main() {
    let reference_to_nothing = dangle();
}

fn dangle() -> &String {
    let s = String::from("hello");

    &s
}

// error[E0106]: missing lifetime specifier
// help: this function's return type contains a borrowed value, but there is no value for it to be borrowed from
```

<br>

## #4.3 スライス型

スライスはコレクション全体だけではなく､その中の一連の要素を取得することができる｡

スライスも所有権のないデータ型である｡

<br>

### **文字列スライス**

String 型は実際のところ､文字の可変長配列である｡

文字列スライスとは､その`String`の一部の参照である｡

文字列スライスを意味する型は`&str`と記述する｡

つまり､文字列スライス`&str`を返すということは､引数として受け取った`String`の 1 部分を参照する文字列スライスを返すということになる｡

```Rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

`[starting_index..ending_index]`鉤括弧で囲い､始まりの要素番号と終わりの要素番号を指定することで､その位置に対応する物の参照を得ることができる｡

![`String`オブジェクトの一部を参照する文字列スライス](https://cloud.r3utools.com/s/2ceCqtizf3EMABL/preview '`String`オブジェクトの一部を参照する文字列スライス')

> Image from [図 4-6: `String`オブジェクトの一部を参照する文字列スライス](https://doc.rust-jp.rs/book-ja/img/trpl04-06.svg '図4-6: `String`オブジェクトの一部を参照する文字列スライス')

また`..`は範囲記法で 0 や最後の要素を省略することができる｡

```Rust
let s = String::from("hello");

let slice = &s[0..3];
let slice = &s[..3];
// これらは等価である

let length = s.len();

let slice = &s[2..length];
let slice = &s[2..];
// これらは等価である

let slice = &s[0..length];
let slice = &s[..];
// これらは等価である
```

<br>

### **文字列リテラルはスライスである**

文字列リテラルは､バイナリにハードコードされている｡

そのバイナリを参照するスライスこそが､文字列リテラルの実体である｡

これこそが､文字列リテラルが不変である理由にもなっている｡

つまり､`&str`は参照であるため､変更することができないのである｡

<br>

### **他のスライス**

文字列以外にもスライスを使用することができる｡

```Rust
let a = [1, 2, 3, 4, 5];
let slice = &a[1..3];
```

このスライスは`&[i32]`という型になり､これも文字列スライスと同じように動作する｡

つまり､配列の要素への参照と長さを保持する｡

<br>
<br>

### まとめ

_Rust 言語も他のシステムプログラミング言語と同じように､メモリの使用法について制御させてくれるわけだが､データの所有者がスコープを抜けたときに､所有者に自動的にデータを片付けさせることは､この制御をするため､余計なコードを書いたりデバッグしたりする必要がないことを意味する｡_
